.___________. _______ .___  ___.      ___          ____   
|           ||   ____||   \/   |     /   \        |___ \  
`---|  |----`|  |__   |  \  /  |    /  ^  \         __) | 
    |  |     |   __|  |  |\/|  |   /  /_\  \       |__ <  
    |  |     |  |____ |  |  |  |  /  _____  \      ___) | 
    |__|     |_______||__|  |__| /__/     \__\    |____/  

Nume:    Maftei Stefan - Radu
Grupa:   324CD
Materie: IOCLA


=== Analiza Statica ===

	In fisierul tema3.c exista doua functii care nu sunt utilizate in cadrul
programului: secret_func1() si secret_func2(). De asemenea in functia play()
se efectueaza un apel al functiei gets() ca sa citeasca informatii de la
intrarea standard intr-un buffer de pe stiva -> acest lucru creeaza o
vulnerabilitate in cadrul programului. Atacatorul poate controla buffer-ul
injectand cod prin el, deci ramane o vulnerabilitate.
	Functia gets() este o functie practic interzisa in programele C din cauza
vulnerabilitatii mari a acesteia: nu verifica limitele buffer-ului in care se
face citirea, putand fi usor folosita pentru buffer overflow. Acest buffer
overflow il vom utiliza pentru a scrie date si pentru a altera fluxul
programului.


=== Determinare User si Parola ===

	Pentru determinarea user-ului si a parolei am urmarit functia login().
Username-ul se afla in variabila name la care i se verifica primele 3
caractere. Acestea sunt "N", "O" si "P" scrise in cod ASCII in baza 16, deci
username-ul valid este "NOP".
	Parola este verificata in functia check_pass(). Fiecarui caracter din
parola ii este asignata valoarea obtinuta aplicand XOR codului ASCII al
caracterului curent si a unei valori de pe aceeasi pozitie din string-ul
key[]. Apoi parola procesata (obtinuta in urma XOR-ului) se compara cu un
string stored_pass[]. Astfel pentru a obtine parola corecta aplicam XOR
valorilor din key[] si a celor din stored_pass[], la fiecare pozitie. Vom
obtine parola "IDA_1z_y0ur_fr1end".


=== Exploatarile cu Buffer Overflow ===

	Pentru a putea apela functiile dorite prin intermediul buffer overflow-ului
vom crea fisiere payload. In ele va trebui sa punem Username-ul, parola,
numarul necesar de octeti pana la adresa de retur pe care o vom suprascrie si
ce necesita fiecare functie. Observam ca pe stiva trebuie sa nu alteram
valoarea variabilei parrot din play(). Astfel vom pune un numar de octeti pana
la locul variabilei parrot, apoi valoarea acesteia, apoi numarul de octeti
necesari pana la adresa de retur.
	Stiva arata astfel in functia play():
	
          |  ret   | 4 octeti
ebp + 4   |________|
          |  ebp   | 4 octeti
ebp 	  |________|
          | parrot | 12 octeti
ebp - 0xc |________|
          |   c    | 1 octet
ebp - 0xd |________|
          |  buf   | 48 octeti
ebp - 0x3d|________|

	Astfel buffer-ul pe care il dam programului va contine 49 octeti cu valori
oarecare (am ales litera "A"), 48 pentru string-ul buf si 1 pentru caracterul c
din functia play(). Apoi punem valoarea lui parrot din functia play(), care
este 44, care ocupa 4 octeti, fiind integer. Urmeaza inca 12 octeti cu valori
oarecare pana la adresa de retur.
	Acesta reprezinta partea initiala a payload-ului inainte de apelarea
functiilor dorite. Adresele functiilor le determinam utilizand comanda
"p <functie>" in gdb. Pentru conversia adreselor si valorilor intregi in array
de bytes am utilizat functia dw() in python, asa cum ne-a fost prezentata la
laborator.

a) secret_func1
	Adaugam payload-ului obtinut adresa functiei.

b) secret_func2
	Adaugam payload-ului obtinut adresa functiei, apoi 4 octeti cu valori
oarecare, reprezantand adresa de retur din functia secret_func2().
	Aceasta functie are nevoie de parametri cu o valoare pe care o gasim
in conditia instructiunii "if" din functie. Primul parametru se afla la
ebp+8, deci vom scrie in buffer paramaetri functiei in ordinea din
signatura ei. Astfel in buffer adaugam 4 intregi care corespund
parametrilor a, b, c, d.

c) fopen
	La fel ca la secret_func2, adaugam payload-ului obtinut adresa functiei.
Apoi avem nevoie de un string cu numele si caracterul "w". Acestea le vom lua
din variabilele functiei main(): prenume si tahw_ni_hsilgne_kaeps_yeht_od.
Obtinem adresele acestor pointeri si adaugam in buffer adresa si offset-ul
pana la valorile dorite (folosim ideea ca pentru un string s de n elemente,
s pointer-ul catre inceputul string-ului, iar s+x va indica la string-ul care
incepe cu al x-lea caracter).
	Astfel se va crea un fisier cu numele indicat.

P.S. : Adresele de retur pentru cele trei functii au fost suprascrise cu
4 octeti oarecare, astfel dupa apelul functiilor rezulta Segmentation Fault.
In locul celor 4 octeti putea fi pusa adresa functiei exit() si totul s-ar
fi terminat fara Segmentation Fault.